# Лекция 1
## 1. Теория вычислительных процессов
- БЦ ВМ (бортовая цифровая вычислительная машина)
- Прямое тестирование - подать входные данные, сравнить выходные данные с ожидаемыми.

В алгоритме должны доказать и обеспечить, что решение существует, является наиболее оптимальным в рамках определенной задачи.

- Семиотика - наука о знаниях.
- Синергетика - объединение (синтез) объектов, приводящее к появлению новых свойств, которые не присущи каждому объекту по отдельности.

### 1.1 Цикл информации
1) Измерительная информация 
2) Первичная обработка информации (регистрация)
3) Вторичная (семантическая) обработка информации (анализ)
4) Формирование управляющих воздействий (должно быть __проактивным__ или предиктивным)

- Таблица измененных значений - набор данных после первичной обработки.

### Семиотика
1) Синтаксис -> первичная обработка
2) Семантики -> вторичная обработка 
3) Прагматика -> формирование программы (управляющих воздействий)

# Лекция 2

Алферова З.В. - теория алгоримтов: учебное пособие для вузов Москва, статистика 1973 год 646 с

Кузнецов О.Д, Аднецов-Вельский Т.М. Дискретная математика для инженера. Москва. Жнергитик 1980 342 с

Чень 4 л и р, математическая логика, какое-то доказательство теоремы

II
Кравец В.Г. Любинский В.Е. - основы управления космическим аппаратом. Москва, машиностроение, 224 с
Креницкий Н.А. - алгоритмы вокруг нас. Москва 1984 г, 212 c
Колмогоров теория информации, теория алгоритмов 1987 г - 304c
Мальцев А.И. - алгоритмы и рекурсивные функции, Москва 1965, 1986-1997
Успенский В.А, Семенов - теория алгоритмов; основные открытия и приложения, Москва 1987 год, 280+с
Яблоснкий С.В. - введение в дискретную математику


## 2. Элементы теории алгоритмов и формальных системных

### 2.1 Понятие алгоритма и его основные свойства

#### 2.1.1 Определение алгоритма
Алгоритм - точное предписание о выполнении в определенном порядке некоторой системы операций для решения всех задач некоторого данного типа. 

аль-Харезим Абу Абдула Мухаммед бен Муса - (787 Хива - 850)

аль джебр

ax^2 + bx + c = 0
P = 0
Диафант
Натисевич

Главным внутри математическим применением теория алгоритмов явились:
- доказательства невозможности алгоритмического решения различных математических проблем
- с точки зрения практической вычислительной математики или кибернетики, алгоритм - это программа *"критерием алгоритмичности"* является возможность запрограммировать эту задачу
- кроме того с точки зрения практической, нужно уметь сравнивать разные алгоритмы для решения одной и той же задачи (по качеству решения, по характеристикам самих алгоритмов, точность) 

#### 2.1.2 Основные подходы к построению алгоритмов

теория алгоритмов:
1) теория рекурсивных функций - основана на понятие числовой функции и ее вычислении
2) Теория интерпретирующих систем (автоматы и машины) - алгоритм реализуется некоторым абстрактным, детерминированным устройством (машин Тьюринга)
3) Алгоритм алфавитных преобразований - основа операторы постановки и вывода на множестве слов _(формальные системы на основе формальных грамматик)_
Все выше перечисленные уточнения/подходы реализации "Алгоритм" задаются с помощью средств алгоритмической системы

Под алгоритмической системой будет понимать всякий общий способ формальной задачи алгоритма

### 2.2 Элементы теории рекурсивных функций

#### 2.2.1 Основные элементы примитивной-рекурсивной функции
В данной функции функция не как функция отображения

Функцию для которой существует вычисляющий ее алгоритм, будем называть вычислимой функцией

рекурсия (лат recurso) - бегу назад

такой способ задания, когда каждое ее значение задается через значение этой же функции или какой-нибудь другой вычислимой функции для меньших и для ранее неопределенных знаений аргументов. Функции задаваемые таким образом будем называть рекурсинвыми.

строятся на основе: 
- функции строятся на основе эелементарных или базисных
- операций или операторов формируемых на ...
1) 

0^n(x1 ..., xn) = 0;

2) функция проекции/тождества, повторяющая значения своих аргументов

I^n (x1, xm, ...xn, ) = xm
  m
3)функция непосредственно следовая
  1
S(x) = x + 1 

замечания: 
предполагается, что все элементарные функции (базисные) являются вычислимыми

# Лекция 3
## Основные свойства алгоритмов (к прошлой лекции)

1) Детерминированность 
Когда одному и тому набору входных данных ставится в соответствии (вычисляется) единственный выходной набор
2) Массовость
Алгоритм применим к некоторому множеству входных данных
3) Результативность
Когда обеспечивается получения результата или выходного набора данных за конечное число шагов

#### 2.2.2 Рекурсивные функции

Вычислимые функции базируются на элементарных функциях: 
- 0-функции, 
- непосредственного следования, 
- функции проекции

Оператор суперпозиции функции - заключается в подстановке одних арифметических функций вместо других

Пусть задана m - местная функция $h_{n}^m(x_{1},...x_{n})$
m-n местная $g_{1}^n(x_{1},..,x_{n})$
			$g_{2}^n$ - до $g_{n}^n$
Fm^n=(h^m1 * g1^n * gm^n) = h^m

$F_{m}^n(h^m, g_{1}^n, .., g_{m}^n) = h^m(g_{1}^n(x_{1}, .., x_{n}), .., g_{n}^m(x_{1}, .., x_{n})$
Элементарные функции и суперпозиции позволяют реализовать всевозможные функции подстановки, переименования и отождествления переменных
$f(x_{1}, x_{2}, x_{3}, .., x_{n}) = f(I_{2}^2(x_{1}, x_{2}), I_{1}^2(x_{1}, x_{2}), x_{3}, .., x_n)$
Дано:
$O^1(x) = 0$;
$S^1(x) = x + 1$;

$F_{1}^1(S^1, O^1) = S^1(O^1(x)) = 0 + 1 = 1$;

Оператор примитивной рекурсии - позволяет строить n+1 местную функцию F^(n+1) по 2-м заданным функциям:

$g^n(x_1, ... x_n)$
$h^{n+2}(x_1, .., x_{n+2})$


f(x, y+1) = h^3(x,y,f(x,y))

Д/з: построить ф-ию, (0-3 для x и y)

Определение
Примитивно рекурсивная функция - функцию полученная из базисной элементарной функции, проекции и ... с помощью конечного числа применения оператора суперпозиции и примитивной рекурсии

Описание любой арифметической функции как примитивно-рекурсивной задает точное математическое описание алгоритма ее вычисления\
арифметической

#### Д/з: Доказать, что функция f(x) = 2x  примитивно-рекурсивная
![[Pasted image 20240923152513.png]]
#### f(x1,x2,x3) = x1,x2,x3 - доказать, что примитивно-рекурсивная
![[Pasted image 20240923152536.png]]

#### 2.2.3 Обще рекурсивные и частично рекурсивные функции

Оператор минимизации или наименьшего корня (мю) - позыоляет определить новую арифметическую функцию f^n(x1,...xn) с помощью ранее известной или построенной функции g^(n+1)(x1,..xn+1):
для любого заданного набора значений переменных <x1, ...xn> = <a1,...an> в качестве
f...
принимается значение наименьшего целого неотрицательного корня y=a в уравнении:
\* g^(n+1)(a1,...an,y) = 0;

Замечание:
Будучи примененной вычислимой функции g снова дает вычислимую функцию. Т.е. мю-оператор сохраняет свойства вычислимости.
Процесс же вычислений реализуется следующим образом: сюда фотку

Пока значение g не ставит равное 0, мы не найдем корень \*.
То минимальное значение y на наборе xy,xn при котором \*  является тождеством и будет значением функции f(a1,..am)=y

Однако в отличии от оператора супер позиции ... такой процесс вычислений может не привести к конкретному результату

Такое событие произойдет тогда, когда уравнение \* не имеет решение (корней), это может произойти в 3 различных случаях:
- когда в самом начале неопределенно значение g и 0;
- когда для y = 0, 1, 2, ... k - значения функции g определены, но для уравнения g является тождеством, но на каждое шаге значение функции g не определено
- когда функция g(x1,..xn,y) является всюду определенной, но ни на одном наборе своих аргументов не выполняется тождество \*


Содержательный смысл мю-оператора
Необходимо отметить, что в примитивной рекурсии отличается от суперпозиции тем, что она учитывает возможность индуктивного перехода при определении функции, а значение y - y+1. при этом заранее задано или известно количество цикла или повторений при вычислении значений определяемой функции.
Применение же мю-оператора хот и сводится к повторному или циклическому вычислению значения определяемой функции, однако все это происходит _без наличия какой-либо априорной информации_ о количестве таких повторений

Арифметические функции, которые могут быть построены из элементарных функций конечного применении оператора суперпозиции, примитивной рекурсии и операторов наименьшего корня (мю) называется частично рекурсивной функцией.

Всюду определенные частично рекурсивные функции называются общей рекурсивной функцией

# Лекция 4
### 2.3 Значение рекурсивных функций. Тезис Черча

ЧРФ представляет собой наибольший общий класс конструктивного задания арифметических функций.
Теор. алгоритм. ставится понятию конструктивизма и изучению конструктивного вычисления и алгоритмов.

Конечная базовая система функций.

Конечная система преобразований этих или других операций, которые задают большое многообразие различных алгоритмов вычисления каких-либо функций.
__Тезис Черча__
Класс алгоритмов или машинно вычислимых частично числовых функций совпадает с классом всех ЧРФ.

**Машина Тьюринга** - это тоже алгоритмическая система; абстрактный автомат.

#### 2.3.1 Основные понятий машины Тьюринга

Для задания м.Тьюринга необходимо задать :
1) Управляющее устройство, которое может находиться в одном из состояний, образующих конечное множество $Q = {q_1, q_2, .., q_n}$.
2) __Бесконечную ленту__, разбитую на ячейки, в каждой из которых может быть записано значение бесконечное алфавита А.
3) Устройство обращений к ленте, которое в каждый момент времени обозревает только одну ячейку этой ленты.
4) Набор команд

#### 2.3.2 Принципы функционирования машины Тюринга
В каждом такте МТ находится в одном из своих состояний множества Q. А головка обозревает одну ячейку.

В следующем такте МТ переходит в другое состояние или остается в том же.

В обозреваемую ячейку записывает символ алфавита А или остается в том же состоянии.
Головка передвигается в L, R или E.
![[Pasted image 20250104141841.png]]
Таким образом, данные для МТ - это слова, записанные на ленте.

Каждый такт МТ заключается в считывании символа, определении состояния; в зависимости от этого, переход в новое состояние, запись в ячейку нового символа и перемещение головки.

Формально, {$q_i a_j$ -> $q_{i}', a', \alpha_k$} = P, 
где  $q_i$ и q - состояние МТ (Q)
$a_j$, a' - обозреваемые символы на ленте до и после выполнения этой команды. (А). $\alpha_k \in {L, R, E}$
Совокупность команд МТ образуют программу (P)

$q_0$ - начальное состояние
$q_z$ - конечное состояние
$\lambda$ - очищение этой ячейки

**Определение**
Полным состоянием МТ называется такая совокупность символов а и q, которая однозначно определяет дальнейшее поведение МТ.

$K_j = \alpha_1 q_i \alpha_{2i}$ , где
$\alpha_1$ - слово на ленте, находящееся слева от обозреваемой ячейки
$q_i$ - текущее состояние 
$\alpha_2$ - слово, образующееся символом, обозреваемым головкой и всеми символами справа от него.

Пример:
$K_5 = b a q_3 d e$

| $\lambda$ | b   | a   | d          | e   | $\lambda$ |
| --------- | --- | --- | ---------- | --- | --------- |
|           |     |     | $\Uparrow$ |     |           |
|           |     |     | $q_3$      |     |           |

Стандартной начальной конфигурацией называется конфигурация вида $k_0 = q_o \alpha$;
Стандартной конечной конфигурацией называется конфигурация вида $k_z = \alpha_1 q_2 \alpha_2$

МТ будем называть абстрактный автомат, задаваемый кортежем, где Q - внутренний алфавит, А - внешний алфавит, $K_0$ - стандартное состояние, P - программа

# Лекция 5
#### 2.3.2 Способы задания МТ

Задать вычислительный алгоритм в алгоритмической системе Тьюринга - это значит задать пример .. по любым внешними или входным данным

Поведение или функционирование МТ может быть задано программой, составленной 3 различными способами:
1) совокупностью команд (перечислением множества P);
2) таблица переходов МТ
3) диаграммой (блок-схемой) переходов МТ

Пример:
1) Совокупность команд
M = < Q, A, $K_0$, P >
Q = {$q_0, q_1, q_2, .., q_z$}
	A = {a, b, c, $\lambda$}
$K_0$ = {$q_0 a b c \lambda$}

1. P = {$q_0a \rightarrow q_1 \lambda R$
	$q_1b \rightarrow q_2 \lambda R$
	$q_2 c \rightarrow q_z \lambda E$}
_Очистка_
2) Таблица переходов

| q/A   | a               | b               | c               | $\lambda$ |
| ----- | --------------- | --------------- | --------------- | --------- |
| $q_0$ | $q_1 \lambda R$ |                 |                 |           |
| $q_1$ |                 | $q_2 \lambda R$ |                 |           |
| $q_2$ |                 |                 | $q_z \lambda E$ |           |
| $q_z$ |                 |                 |                 |           |

3) Диаграмма переходов
a->$\lambda$R    b->$\lambda$R     c->$\lambda$R
($q_0$) $\Rightarrow$ ($q_1$) $\Rightarrow$ ($q_2$) $\Rightarrow$ ($q_z$)

#### 2.3.3 Вычисления на Машине Тьюринга
В соответствии с конфигурацией МТ со всякой не заключиительной применимо некоторая команда МТ, после такого применения МТ переходи в новую конфигурацию $k(i+1)$.


Если для некоторых Ki и Kj при ее функционирование
$\exists$ такая последовательность смены конфигурации из $Ki -> Ki+1, .. K$j, то этот факт будем обозначать .. 

Пусть f - некоторая функция, отображающая множество слов из алфавита Aисх в Aрез в общем виде.
Говорят, что МТ М правильно вычисляет функцию f, если выполняется 2 условия:
1) 
$f(V) = W;$
$q_1V => q_zW$ -> в тетради еще штучка

2) .
существует V; f(V) - не определено, то МТ, запущенная в стандартной начальной конфигурации $qoV$, работает бесконечно.

Если для некоторой функции f существует МТ M, которая ее правильно вычисляет, то f называется *(правильно) вычислимой по Тьюрингу*
Замечания: 
2 МТ являются эквивалентными если они правильно вычисляют одну и ту же функцию

#### 2.3.4 Тезис Тьюринга

Всякий алгоритм может быть реализован на МТ.

Замечания
Сформулированный тезис позволяет утверждать, что если не возможно создать Мт для вычисления какой-либо функции, то алгоритма вычисления такой функции не существует вообще

Доказательства этого тезиса не существует, поскольку само понятие алгоритма для МТ, определено неявно (интуитивно)

Подтверждением тезиса Тьюринга могут служить следующие неформальные обстоятельства:
- практика создания программ для МТ по всем известным вычислимым функциям;
- сводимость описания алгоритма в любой алгоритмической системе к МТ

Отсутствие алгоритма относится к решению "проблемы остановки" для произвольной МТ.
Проблема определения выводимости в любой логической теории

### 2.4 Алгоритмическая системам Поста

Эмиль Пост 1897

#### 2.4.1 Понятие формальной системы


Теория формальных систем рассматривает только синтаксические свойства изучаемых объектов - слов, то есть математические объекты в формальных системах понимаются как последовательности символов или слова в некотором фиксированном алфавите, а операции над этими объектами или словами являются операциями над символами или словами.

1) Формальная система называется математический кортеж <A, $A_1$, R>, 
где А - конечный алфавит
A = {a, b}; |A| = 2;
A* = {$\emptyset$, a, b, ab, ba, ...}; |A*| = $\infty$
$A_1$ - множество правильно построенных выражений в A (аксиом)
$A_1 \in A*$
R - количество множеств вычислимых выражений вида R = {($\alpha_1, ..., \alpha_n, \beta$)}
$\alpha_n, \beta \in A*$

MT = FS - ?
M = < *Q, A*, $K_0$, _P_ >
FS = < *A*, $A_1$, _R_ >
A - алфавит целых чисел
$A_1$ - исходные данные

#### 2.4.2 Система Туэ Аксель

ДЗ: $1^4 + 1^5 = 1^{4+5}$
1111 + 11111 = 

1) Совокупность команд
$q_01 \rightarrow q_01R$;
$q_0+ \rightarrow q_11R$;
$q_11 \rightarrow q_11R$;
$q_1 \lambda \rightarrow q_2 \lambda L$;
$q_21 \rightarrow q_2 \lambda E$
2) Таблица состояний

| q/A    | 1         | +         | $\lambda$       |
|--------|-----------|-----------|-----------------|
| $q_0$  | $q_01R$   | $q_11R$   |                 |
| $q_1$  | $q_11R$   |           | $q_2 \lambda L$ |
| $q_2$  | $q_2 \lambda E$ |     |                 |

3) Диаграмма переходов
![[Pasted image 20250105104128.png]]

# Лекция 6

#### 2.4.2 Частный случай Туэ Аксель
Определение:
Система подстановок или полусистема Туэ определяется как формальная система через следующие элементы: A(алфавит), конечное множество подстановок вида $Ri(\alpha_i, p_i) = {\alpha_i \rightarrow p_i}$
$ai, pi \in A$

$alpha_i \rightarrow p_i$
a, b интерпретируются как некоторое правило вывода как $R_i$

Из некоторого слова $\gamma$ выводимо слово $\delta$, для всех $\gamma, \delta \in A*$

если  $\delta$ получается из $\gamma$ путем подстановки слова $\beta_i$ вместо какого-либо вхождения слова $\alpha_i$ в это слово $\gamma$


Тогда выводом полусистемы называется цепочка 
$\beta из \gamma \alpha: \alpha + E_1 + E_2 + ... + E_n + \beta; \alpha \Rightarrow \beta$;


Ассоциативным исчислением или системой Туэ называется такая формальная система, определяемая некоторым алфавитом A и конечным множеством соотношения вида Ai: ai <-> bi, каждая из которых (<=> 
ai -> bi; 
bi -> ai)
Если из a выводимо b в асс. исч, то _a + b => b + a_
a => b => b => a

В асс. исч отношение (<->) в соответствующей подстановке является отношением эквивалентности, т.е. этому отношению эвк. соответствуют след. свойства:
- рефлективности $\forall (\alpha \in A*) (\alpha \leftrightarrow \alpha)$;
- транзитивности $\forall(\alpha, \beta \in A*)(\alpha \leftrightarrow \beta$ & $\beta \leftrightarrow \gamma) \Rightarrow (\alpha \leftrightarrow \gamma)$
	- симметричность $\forall(\alpha,\beta \in A*) (\alpha \leftrightarrow \beta) \Rightarrow (\beta \leftrightarrow \alpha)$
Примечание: 
Применение асс. исч: 
		Поскольку выводимость в  АИ - отношение эквивалентности, то задачей обработки построения оптимальных планов может служить следующие определения эквивалентных отношений  и определения некоторого плана

Пример:

#### 2.4.3 Частный случай формальной системы. Определение канонической система Поста
Система Поста определяется как формальная система $FS_p <A, X, A_1, R>$, 
	где А = {$a_1, ... a_n$} - собственный алфавит
	X = ($x_1, ... , x_n \in A*$) - алфавит или множество переменных
	$A_1$ - конечное множество аксиом  $\in A, X$
	R - конечное множество правил вывода $\gamma_1, \gamma_2 - посылки, \delta - следствие$

Формальная система Поста
Некоторое слово альфа получается применением некоторой аксиомы омега из множества в том случае, если переменных в омега подставляются слова из А*

Некоторое слова $\alpha$ непосредственно выводимо из слов $\alpha_1$, ..., $\alpha_n$ применением продукции из $R_i$ с n посылками, если *найдется такая подстановка слов вместо переменных в $R_i$, которая посылки в $R_i$ превращает в соответственно слова $\alpha_1$, ... $\alpha_n$, а заключение правило $R_i$ непосредственно в слове $\alpha$.*
_Пример в тетради_
acab, cabb $\vdash$ bb; ?
$R_I = ax_1b, x_1bx_2 \vdash bx_2$
$x_1 = ca; x_2 = b$

###### О2
Последовательность слов называется док-вом в система Поста, если каждое слово этой последовательности:
- Либо результат применения аксиомы;
- Либо непосредственно выводимо из предыдущих слов последовательности применением некоторой продукции

Слово $\alpha$ называется доказуемым или теоремой, если оно является последним словом некоторого доказательства

Пример: построить ФСП, перечислить все нечетные числа
A = {1}
X = {x}
$A_1$ = {1}
R = {x -> 11x}
Если четные, то меняем аксиому $A_1$ = {11}
1, 111, 11111

### 2.5 Алгоритмические формальные системы и проблемы разрешимости

####  2.5.1 Неклассические алгоритмические системы

С широким распространением ЭВМ стали возникать другие виды алгоритмических системы более ориентированные к алгоритмизации задач, решаемых на компьютере.
Среди них выделяют:
- операторные алгоритмы Ван Хао;
i: | w | $\alpha$ | $\beta$ | , i - номер приказа, w - элементарная операция над объектом, $\alpha, \beta$ - номера дальнейших приказов
- операторные алгоритмы А.А. Ляпунова;
p(x < y), если истинно, то выполняется, если нет, то не выполняется
- Блок-схемный метод алгоритмизации;
ВНД - время нормированного документа,
ЗПД - заработная плата документа,
ВНД = $\sum_{i=1}^n{k_ixt_i}$
ЗПД = $\sum_{i=1}^n{K_ixp_i}$
- Логические схемы Ю.И. Янов



#### 2.5.2 Разрешимые и перечислимые множества (Лекция 7)

# Лекция 7
#### 2.5.2 Разрешимые и перечислимые множества
Прикладные результаты теории вычислительных процессов в основном заключаются в определении принципиальной разрешимости различных задач, требующих своего решения

Некоторое множество M называется разрешимым (или рекурсивным), если существует некоторый алгоритм $A_n$ по любому объекту a дает ответ принадлежит ли множеству М. В этом случае алгоритм $а_м$ называется разрешимой этого множества М.
Множество М разрешимо, если оно обладает обще рекурсивной характеристической функцией (всюду определенной), которая дает значение 1
Множество М называет перечислимым или рекурсивно перечислимым, если это множество является областью значений некоторой общерекурсивной функции (ОРФ), т.е. существует ОРФ
$\exists \psi_m(x):$
если $\alpha \in M \Leftrightarrow \alpha = \psi_m(x)$

Функция $\psi_m$ называется перечисляющей для множества М, и соответственно алгоритм, вычисляющий значение этой функции является тоже перечисляющим или порождающим

*Замечание* (важность понятия различимости и перечисления)
Благодаря применению или использованию становится точным математически
"конструктивный способ задания M"
"множество М, заданное конструктивно"

*Замечание*
С теоретической точки зрения неразрешимости какой-либо проблемы или задачи не является неудачей, а научный факт.
Знание основных не разрешимостей теории алгоритмов является таким элементов научной культуры, как для физики знания невозможности создания вечного двигателя

Рекомендации:
1) Отсутствие общего алгоритма, решающего данную проблему не означает отсутствие разрешимости в частых случаях. Из этого  следует - необходимо искать не разрешимые частные случаи
2) Появления неразрешимостей - это, как правило, результат чрезмерной общности постановки задач, а это означает, что задача в более общей постановке имеет больше шансов оказаться не разрешимой.


## 3 Автоматные модели

### 3.1 Основные понятия теории конечных автоматов
#### 3.1.1 Определение
Конечным автоматом называется кортеж S (пятерка) <X, Q, U, $\delta$, $\lambda$>, где
X = {$x_1, .., x_n$} - входной алфавит
Q - внутренний алфавит
U = {$u_1, .., u_n$} - выходной алфавит
$\delta$: X * Q -> Q - функция перехода
$\lambda$: X * Q -U - функция выхода

a             b
--->S--->
$a\in x\star$    $b \in U\star$

#####  Функционирование конечно автомата

Функционирует дискретно по тактам и шагам.
Рассмотрим такт функционирования i
x(i) $\in$ X;
q(i) $\in$ Q -> q(u+1);
u(i) $\in$ U;

а) КНА 1-го рода (Мили)
	q(i) = $\delta$(x(i), q(i-1));
	U(i) = $\lambda$(x(i), q(i - 1));

б) КНА 2-го рода (Мура)
	q(i) = $\delta$(x(i),q(i - 1));
	u(i) = $\lambda$(q(i)) = $\lambda$($\delta$(x(i), $\delta$(i-1)))

КНА S, функционирование которого всегда начинается с некоторого начального состояния $q_0 \in Q$, называется инициальным

Замечание:
Обычно рассматривают конечные автоматы, в которых рассматривают  $Q_p \in Q$ (множество конечных состояний)
$q_i \in Q_F$ КНА останавливается (завершает свою работу)

#### 3.1.2 Способы задания конечных автоматов

1) Создание матрицы переходов $\delta$ и $\lambda$ 
$\bigtriangleup(\delta)$
$\bigtriangleup(\lambda)$
$\bigtriangleup/\bigtriangleup$ = 


| Q/X | X1  | X2  |
| --- | --- | --- |
| q1  |     |     |
| q2  |     | q1  |
| ... |     |     |

2) Граф или диаграмма переходов  
Г = < Q, ($\delta, \lambda$) >;

$x_k/u_m$
($q_i$) $\longrightarrow$ ($q_j$)

3) 
M = ||$M_{ij}$||
$m_{ij} = x_i/u$

| q / q | q1  | q2  | q3  |
| ----- | --- | --- | --- |
| q1    |     |     |     |
| q2    |     |     | x/u |
| q3    |     |     |     |
__Пример:__ S = < X, Q, U, $\delta, \lambda$ >;
X = {a, b, c, d};
Q = {$q_1, q_2, q_3$};
U = {0, 1}

$\bigtriangleup/\bigtriangleup$ = 

| X / Q |     a   |   b    |    c    |    d    |
|------|------|------|------|------|
|   $q_1$   | $q_2$/0  | $q_3$/0  | $q_3$/1   | $q_1$/1  |
|   $q_2$   | $q_3$/0  | $q_3$/1   | $q_1$/1  | $q_2$/0  |
|   $q_3$   | $q_3$/1  | $q_1$/1    |  $q_2$/0 | $q_1$/0 |

	Д/з: автоматную матрицу (1 способ)

| Q/Q   | $q_1$         | $q_2$         | $q_3$         |
| ----- | ------------- | ------------- | ------------- |
| $q_1$ | $\frac{d}{1}$ | $\frac{a}{0}$ | $\frac{c}{1}$ $\frac{b}{0}$ |
| $q_2$ | $\frac{c}{1}$ | $\frac{d}{0}$ | $\frac{b}{1}$ $\frac{a}{0}$ |
| $q_3$ | $\frac{b}{1}$ $\frac{d}{0}$ | $\frac{c}{0}$ | $\frac{a}{1}$ |
![[Pasted image 20250105134159.png]]
$q_1 \in Q_i \subset Q_{0i}$
$\alpha = bbcd \Rightarrow \beta$ = ?
$\beta = 0110$

L = {$\alpha$}
L = {$a^mb^n$| m, n >0}
S - ? (построить), при U = {0, 1}
Q = ?, если $q_i \in Q_f \Rightarrow U(i) = 0$, иначе U(i) = 1.

# Лекция 8
#### 3.1.3 Полнота и детерминированность 
Полнота:
Полным КНА называют такой КНА, который имеет всюду определенную функцию перехода и выхода.
$\forall x_i \in X, \forall q_j \in Q$
$\exists q_k = \delta(q_j, x_i)$;
$U_k=\lambda(q_j, x_i)$;

Частичный КНА - такой автомат, у которого $\delta и \lambda$ определены не для всех пар входного алфавита Х и алфавита внутреннего состояния Q.

__Замечание:__ Для ЧКНА множество слов недопустимого для этого автомата называют множеством запрещенных слов.

Детерминированным КНА называются такой автомат S, который имеет однозначную функцию перехода $\delta$, т.е. в графе переходов из каждой вершины должна выходить не более, чем одна дуга, помеченная одним и тем же символом.

В автоматной матрице М любой входной символ встречается в строке матрицы не более 1 раза. В противном случае - автомат недетерминированн.
	b
($q_i$) $\curvearrowright$ ($q_j$)
    a

### 3.2 Синтез КНА 
Синтез - построение КНА по описанию множеств слов во входном алфавите, который допускаться этим КНА

Анализ - процесс обратный к синтезу - получение множества входных слов, допустимых этим КНА по известному или заданному КНА.
Анализ предполагает о предъявлении слову определение допуска слова в заданному КНА.

__Замечание:__
Синтез - процесс модели функционирования
Анализ - процесс распознавания входных слов по результатам объекта контроля.

#### 3.2.1 Регулярные выражения
R ~ X = {$x_1, ..., x_n$} определяется рекурсивно
Следующим образом:
1) R = $\emptyset$
2) $a \in X \Rightarrow$ R = a (один символ)
3) $R_1, R_2 и \wedge, \vee, () <>$, то
		а) R = ($R_1 \vee R_2$);
		б) R = ($R_1 \wedge R_2$);
		в) R = ($R_1$)*; R = ($R_2$)*

(R)* = $\bigvee_{i=0}^{\infty}R^i$ = $\emptyset + R + RR + RRR + ...$
4) Ни что другое не является регулярным выражением

__Замечание:__
Рекурсивное определение означает такой способ задания формулы, функции, при котором эта конструкция на некотором шаге определяется через такую же конструкцию с предыдущего шага.
__Пример:__
X = {a, b, c, d};
1) R = (a $\vee$ b) c $\Leftrightarrow$ L(x) = {ac, bc}
2) R = (a b c $\vee$ a) (a b d) $\Leftrightarrow$ L(R) = {abcabd, aabd}
3) R = (a* $\vee$ b* $\Leftrightarrow$ L(R) = {$\emptyset$, a, b, aa, abb..}.
4) (a $\vee$ b)* c $\Leftrightarrow$ L(R) = {ac, bc, aabac, bbc, c, ..}
5) Про спутник: L(R) = {abcd, abcdabcd, ..}
ДЗ:
6) R = a* b* $\Leftrightarrow$ L(R) = {$\emptyset$, a, b, aa, bb, ab ...}
7) L(R) = {$a^n, b^m$ | n, m >= 0 }; R - ? (см п.3)
8) L(R) = {$a^n, b^n$ | n >= 0 }; R - ?

#### 3.2.2 Разметка регулярных выражений
$\exists$ R: x = {$x_1, ..., x_n$} разделяющее местами, будем называть разделительными символами. В R будем выделять начальными и конечные места.

__Пример:__ X = {x, y, z};
R = (z v x < y v z >); 
R = | ( | z | v | x | < | y | v | z | > | ) |;
    0 1   2   3   4   5   6   7   8   9   10

R = $x_{i1}, x_{i2}, ... x_{in}$,  - произвольные регулярные выражения 
Тогда "a" связано $\varpropto$ "b" можно перейти $\in$ пом. любого числа:
- непосредственно переходов;
- переходов через символы, взятых по 1 разу в том порядке, в каком они входят в слово $\alpha$ 
- a - следует за местом $\alpha$ $\Leftrightarrow$ 
всякое место a связано с местом b в слове a
- Если от места a к месту b можно перейти с помощью одних лишь переходов, то есть если а связано с b - E(путем символов)

# Лекция 9
#### 3.2.3 Правила подчинения места в регулярном выражении


i          j           i          j
|   $\searrow$   |  или  |  $\swarrow$   |

1) Начальные места всех термов или букв или символов многочлена, помещенных в "( )" или "< >" подчиняется месту, располагающемуся слева открывающей скобки
(a $\vee$ b) | ( a | $\vee$ | b | ) |
  \             $\searrow$ 
  
1) Место, располагающее справа от закрывающей скобки, подчинено конечным местам всех термов многочлена, заключенных в эти скобки. А в случае "< >" еще и месту слева от открывающей скобки
| ( | a | $\vee$ | b | )   | < | a | $\vee$ | b | > |
.    $\searrow$            $\searrow$   $\searrow$       $\searrow$       $\searrow$ 


3) Начальные места всех термов многочлена заключены в "< >", подчиненных месту расположенных справа от закрывающей скобки
| < | a | $\vee$ | b | > |
.                     $\swarrow$$\swarrow$

4) Если место "с" подчиняется месту "b", а место "b" подчиняется месту "a", то место "c" подчиняется месту "a"
5) Каждое место подчиняется самому себе
6) Других случаев подчинения в регулярных выражениях нет.

Х - алфавит (без вспомогательных символов)
Основным местом называют место, слева от которого находится символ алфавита X, а также начальное место
0  1   2   3   4   5
| ( | a | v | b | ) |

Место справа будет предосновным (выше 1, 3)

#### 3.2.4 Описание алгоритма синтеза конечного автомата по регулярному выражению

Пример следующее правило метки, синтеза автомата.
Каждое состояние $q_i$ определяется подмножество множества основных мест в регулярных выражения, отмечается множество, содержащее все те и только те выражения $R_1$,, конечные места которых подчиняются хотя бы одному основному месту из числа месту, входящему в подмножество $q_i$ .

Некоторое слово $\alpha$ $\in$ (X)* переводит в S тогда (из $q_0$ в $q_j$), когда начальное место регулярного выражения $R_i$ связано с конечным местом словом $\alpha$

1. В заданных $R_1, ..., R_p$ все места различны
2. Каждому основному месту, в качестве его индекса предписывается N (некоторое число). При этом все начальным места предписывается индекс О. Все введенные индексы, отмечаются основные места, называющиеся основными индексами.
3. Каждому основному индексу (а) распространяется в качестве неосновного индекса на все места, подчиняются месту (а), но отличны от него самого. При этом каждому месту (p) получ. множество индексов.
4. Каждому состоянию синтез автомата S отмечается подмножество множества всех основных индексов, которые будем обозначать $q_i \rightarrow i_1 \vee i_2 \vee i_3 ..., i_1, i_k$ - основные индексы. 
   Пустое множество -> ().
   Начальное состояние $q_0 \rightarrow {\emptyset}$
   Таблица переходов формируется следующим образом.
   На пересечении $X_i$ строки ($x_i \in X$) и $g_j$ столбца ($g_j \in Q$) нашего множество индексов, отмеченное это состояние автомата, в числе которого находятся индексы всех тех, мест, в которых $x_i$ следует за предосновными местами, и в числе индексов которых имеется хотя бы один индекс об. $g_j$. В противном случае, на пересечении имеется ().
   5. $i_1 \vee i_2 \vee i_3 ...$ Каждое подмножество отмеченных состояний КНА и соответствующий столбец отмеченный подмножеству множества $R_1 ... R_p$, конечно места которых содержит индекс $R_1 ... _k$ 
__Пример:__
$R_1$ = < x > < y >; $R_2$ = < x $\vee$ y > x
1) R = | < | x | > | < | y | >|,  | < | x | $\vee$ | y | > | x |;
2)      (0)        1              2     (0)       3         4         5
3)            |0|       0   |0|      0        0        0         0
.                 | 1|       1    |1|     (1)       3        3         3
.                                  |2|       2        4        4         4

.       ($R_1$)  ($R_1 \vee R_2$)        ($R_1$)           ($R_2$)          ()

| X / Q | $\emptyset$ | 1 v 3 v 5 | 2 v 4 | 3 v 5 | 4     |
| ----- | ----------- | --------- | ----- | ----- | ----- |
| x     | 1 v 3 v 5   | 1 v 3 v 5 | 3 v 5 | 3 v 5 | 3 v 5 |
| y     | 2 v 4       | 2 v 4     | 2 v 4 | 4     | 4     |

$\emptyset$ -> $q_1$
1 v 3 v 5 -> $q_2$
2 v 5 -> $q_3$
3 v 5 -> $q_4$
4 -> $q_5$

($R_1$) -> $\emptyset$
($R_1 \vee R_2$) -> 1
($R_2$) -> 2
() -> 3

$\frac{\bigtriangleup}{\bigtriangleup}$= 

| Q/Q   | X             | Y             |
|-------|---------------|---------------|
| $q_1$ | $\frac{q_2}{1}$ | $\frac{q_3}{0}$ |
| $q_2$ | $\frac{q_2}{1}$ | $\frac{q_3}{0}$ |
| $q_3$ | $\frac{q_4}{2}$ | $\frac{q_3}{0}$ |
| $q_4$ | $\frac{q_4}{2}$ | $\frac{q_5}{3}$ |
| $q_5$ | $\frac{q_4}{2}$ | $\frac{q_5}{3}$ |
![[Pasted image 20250106175242.png]]
$\alpha_1 = xy; \Rightarrow U = \emptyset;$ $\alpha \in R_1$
$\alpha_2 = xyx; \Rightarrow U = 2;$ $\alpha \in R_2$
$\alpha_3 = yxy; \Rightarrow U = 3;$ $\alpha \notin R_1,R_2$

# Лекция 10
## 3.3 Минимизация конечного автомата

#### 3.3.1 Необходимые определения

X*              U*
--->[ S ] ---> 

$S_1$ = < $x_1, Q_1, U_1, \delta_1, \lambda_1$ >
$S_2$ = < $x_2, Q_2, U_2, \delta_2, \lambda_2$ >

g = < $g_1, g_2, g_3$ >

{ $g_1: x_1 \rightarrow x_2$;
{$g_2: Q_1 \rightarrow Q_2$;
{$g_3 : U_1 \rightarrow U_2$;

Гомоморфизм

$\forall x \in X_1$; $q \in Q_1, U \in U_1$;
{$\delta_2(g_1(x), g_2(q)) = g_2(\delta(x, q))$;}  *
{$\lambda(g_1(x), g_2(q)) = g_2(\lambda_1(x, q))$;}

__Пример:__
A = {$a_1, ..., q_n$}
B = {$b_1, ..., b_n$}
$h_1: A \rightarrow A$;
$h_2: B \rightarrow B$;
$g: B \rightarrow B$;
$\forall a \in A[h_2(g(a)) = g(h_1(a))]$;
![[Pasted image 20250107180645.png]]


###### О:
$S_1, S_2$ называют изоморфными, если отображение g является изоморфом (взаимноодназнычными)

###### O 
$S_1= < X, Q_1, U, \delta_1,\lambda_1 >$
$S_2 = < X, Q_2, U, \delta_2, \lambda_2 >$
$\alpha = X_{i1}, X_{i2}$
Если $S_1$ из q' $\in Q_1$ преобразует входное $\alpha$ некоторое выходное $\beta   U   S_2$ из q'' $\in Q_2$ тоже $\alpha$ и $\beta$, то $S_1$ и $S_2$ соответственно называет неотличимыми 

###### O
$\forall q' \in Q_1 S_1 \exists q'' \in Q_2 S_2, то S_1$ и $S_2$ эквивалентны.

__Замечание:__
Эквивалетные КНА означает реализацию одинакового отображения входных слов выходным словам.

Задача минимизации - это задача нахождения КНА с наименьшими и эквивалетным количеством состояний (к $S_0$)
1) $\forall S \exists S_0$ всегда с существует единственный, с точностью до изоморфизма.
2) Если количество состояний Q КНА S _разбивается_ на l классов эквивалетными (l <= [Q]), т.е. 
$Q_1 = \{q_{11}, q_{12}, ..., q_{1i}\}, ...,$
$Q_l = \{q_{l1}, q_{l2}, ..., q_{li}\}$.
то $S_0 - |Q_0| = l$

__Замечание__:
Таким образом, для неподходящих $S_0$ необходимо найти разбиение множеств состояний Q на классы эквивалетности.


####  3.3.2. Алгоритм минимизации конечного автомата (алгоритм мили)

Алгоритм работает по шагам, на каждом шаге множество состояний Q разбивается на более мелкие подмножества

# Лекция 11
#### 3.3.2 Алгоритм Мили
S = < X, Q, U, $\delta, \lambda$ >
Q = {$q_1, q_2, ..., q_n$};

Алгоритм работы по шагам. На i-ом шаге Q разбивается на более мелки подмножества.
- 1) q', q'' $\in Q \rightarrow Q_1$;
Относим в один класс, если выполняется следующее соотношение $\forall x \in X: \lambda(q', x) = \lambda(q'', x)$
- i+1) q', q'' $\in Q_i$; $\rightarrow Q_{i+1}$
$\forall x \in X: \delta(q', x), \delta (q'', x) \in Q_i, l$
В конце каждого i + 1 шага:
1) (i+1) шаг не изменяется
$\forall j [Q_{i,j} = Q_{i+1, j}]$, то алгоритм заканчивает работу
2) Переход к следующем шагу
S: X = {a, b, c};
Q = {$q_1, ..., q_g$}
U = {0, 1}

$\frac{\bigtriangleup}{\bigtriangleup}$=

| Q / X | a   | b   | c   |
| ----- | --- | --- | --- |
| 1     | 2/0 | 4/1 | 4/1 |
| 2     | 1/1 | 1/0 | 5/0 |
| 3     | 1/1 | 6/0 | 5/0 |
| 4     | 8/0 | 1/1 | 1/1 |
| 5     | 6/1 | 4/1 | 3/0 |
| 6     | 8/0 | 9/1 | 6/1 |
| 7     | 6/1 | 1/1 | 3/0 |
| 8     | 4/1 | 4/0 | 7/0 |
| 9     | 7/0 | 9/1 | 7/1 |
1) (1, 4, 6, 9)  (2, 3, 8)  (5, 7)
Это классы эквивалентных состояний
2) (1, 4, 6)  (2, 3, 8)  (5, 7)  (9) 
3) (1, 4)  (2, 3, 8)  (5, 7)  (9)  (6)
4) (1, 4)  (2, 8)  (5, 7)  (9)  (6)  (3)
5) ----//----
$Q_0$ = {$q_1^o, q_2^o, q_3^o, q_4^o, q_5^o, q_6^o$}

| Q / X | a   | b   | c   |
| ----- | --- | --- | --- |
| 1     | 2/0 | 1/1 | 1/1 |
| 2     | 1/1 | 1/0 | 3/0 |
| 3     | 5/1 | 1/1 | 6/0 |
| 4     | 3/0 | 4/1 | 3/1 |
| 5     | 2/0 | 4/1 | 5/1 |
| 6     | 1/1 | 5/0 | 3/0 |
ДЗ: 
1) Сделать диаграмму переходов для исходного и мин. КНА
2) Рассмотреть КНА, который синтезирован по т. Глушкова с результатом



### 3.4 Анализ конечных автоматов

#### 3.4.1 Синтез КНА
построение конечного автомата по описанию множества слов во входном алфавите, которые должны допускаться в этом входному алфавите

Анализ конечного автомата - обратная задача синтезу - получение описания множества входных слов по известному конечному автомату

Теорема Клини С. 
1) Проблема синтеза
Для любого регулярного выражения R всегда существует КНА, допускающий все множество входных слов (и только его), представимое этим регулярным выражением
2) Проблема анализа
Любой КНА допускает такое множество входных слов, которое может быть представлено некоторым регулярным выражением R

__Замечание:__
Множество входных слов, допускаемых КНА, получило название регулярного множества (языка) L(S)


#### 3.4.2 Алгоритм анализа конечного автомата
(j) - номер такта = 0, 1, 2, ...
($x^j \in X$) - входной символ на j-ом такте
($q^j \in Q$) - состояние на j-ом такте
($u^j \in U$) - выходной символ на j-ом такте
$\alpha$ - выходное слово
НАЧАЛО
0) j = 0; $q^j = q_0$;
$x^j = \emptyset$; - автомат стоит
$u^j = \emptyset$; 
1) j = j + 1
2) $q^j = \delta(x^j, q^{i-1})$
3) $u^j = \lambda(x^j, q^{i-1})$
4) j != |$\alpha$| -> на п.1
5) если $u^j \in U_F$
$\alpha \in L(S)$
ДЗ:
1) Как изменится алгоритм, если КНА - частичный (заполнены не все состояния)?
2) Как изменится алгоритм, если КНА неинициален?

#### 3.4.3 
$\frac{\bigtriangleup}{\bigtriangleup}$=

| Q / X | X   | Y   |
| ----- | --- | --- |
| 1     | 2/1 | 3/0 |
| 2     | 2/1 | 3/0 |
| 3     | 4/2 | 3/0 |
| 4     | 4/2 | 5/3 |
| 5     | 4/2 | 5/3 |
$R_1$ = < x < y >
$R_2$ = < x $\lor$ y > x

$\alpha$ = xxxy;

| j   | $x^j$ | $q^j$ | $u^j$       |
| --- | ----- | ----- | ----------- |
| 0   | -     | 1     | -           |
| 1   | x     | 2     | 1           |
| 2   | x     | 2     | 1           |
| 3   | x     | 2     | 1           |
| 4   | y     | 3     | $\emptyset$ |
$\Rightarrow \alpha \in L(S) (R_1)$

$\alpha$ = xyx
|   | x | q | u |
| -- | - | -- | -- |
| 0 | - | 1 | 0 |
| 1 | x | 4 | 2 |
| 2 | y | 5 | 3 |
| 3 | 

# Лекция 12
## 4. 

### 4.1 Структурные модели лингвистических процессов

#### 4.1.1 Определение формальной грамматики и языка

Формальной грамматикой `G` называется кортеж $< N, T, R, S>$ , 
где 
N - конечное непустое множество не терминальных, вспомогательных символов;
T - конечное непустое множество терминальных (основных), причем (N $\cap$ T = $\emptyset$):
R - конечное множество упорядоченных пар $\alpha$, $\beta$; R = {($\alpha, \beta$)} = {$\alpha \rightarrow \beta$}:
S - начальный символ аксиом для системы, $S \in N$

__Замечание:__
N = {A, B, C, S}
T = {a, b, c}

###### O.
Продукции (правило вывода) грамматики G  определяется следующим образом 
$R = \{\alpha \rightarrow \beta\}\alpha \in (N \cup T)^* * N * (N \cup T)^*$
$\beta \in (N \cup T)^*$

-> [отношение порядка]()
 - рефлексивность;
 - антисимметричность;
 - транзитивность

###### Определение выводимости
Будем говорить, что из некоторого слова $\gamma$ выводимо некоторое слово $\epsilon$ ($\gamma \Rightarrow_\alpha \epsilon$), причем каждое 
$\gamma, \epsilon \subset (N \cup T)^*$

{$\gamma = \delta_1\alpha\delta_2$
{$\epsilon = \delta_1\beta\delta_2$           $(\alpha \rightarrow \beta) \in R$

###### O.
Будем говорить, что из $\gamma$ выводимо из $\epsilon$, если существует такие $\gamma_0 = \gamma$ и $\gamma_n = \epsilon$
Последовательность называется выводом длины n
$\gamma \Rightarrow_G^* \epsilon$
$\gamma_0 = \gamma$; $\gamma_n = \epsilon$
$\gamma_0 \Rightarrow_G \gamma_1 \Rightarrow_G \gamma_2 \ldots \Rightarrow_G \gamma_n = \epsilon$;
$\gamma_0, \gamma_1, \ldots , \gamma_n$ - вывод n-малого


###### O.
Языком L(G) порожденным грамматикой G называется следующее множество:
L(G) = $\{\alpha|S\Rightarrow{_G}{^*}\alpha; \alpha \in T^*\}$

$\alpha \in T^*$, состоящих только из терминальных символов


###### O.
$\alpha \in L(G)$ - длина цепочки $\alpha$ (|$\alpha$|)
__Пример:__
G = < T, N, R, S >
T = { a, b, c, \*}
N = { S, A }
R = { S -> S \* S, (1)
S -> A + A,         (2)
S -> A,                (3)
A -> A \* A,         (4)
A -> a}               (5)
$S \Rightarrow^2 A + A \Rightarrow^4 A \cdot A + A \Rightarrow^5 a \cdot A + A \Rightarrow^5 a \cdot a + A \Rightarrow^5 a \cdot a + a$;



###### O.
D - помеченное дерево (граф вывода), если 1) корень помечен S, 2) $D_1, \ldots, D_n$ - поддерево, то корень каждого $D_i$ помечен либо $A_i \in N$ (больше одной вершины у $D_i$), либо $a_i \in N$ (одна вершина у $D_i$)
__Замечание:__ 
Каждое $D_i$ - дерево вывода в грамматике G = < T, N, R, $A_i$ >, в котором $A_I$ - аксиома

__Пример:__
				S
		A                +               A
	A        *      A                         a
	a                 a

Свойство однозначности характеризует грамматику, а не язык, поскольку один и тот же язык может быть описан различными грамматиками


#### 4.1.2 Классификация ФГ и языков
					ФГ
Распознающие    Порождающие    Преобразующие


###### O. Распознающие
позволяет ответить на вопрос, является ли цепочка правильной (принадлежит или нет?)

###### O. Порождающие
Позволяет строить любую правильную цепочку, давая при этом писание структуры, и не дает строить неправильные цепочки

###### O. Преобразующие
Для любой правильной цепочки, позволяет строить отображение её, задавая порядок реализации


| Тип         | Название                     | Вид нор. правил                                                                                                           |
| ----------- | ---------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| 3           | Регулярные                   | $\alpha \in N; \beta \in T\cdot N$                                                                                        |
| 2           | КС (конкретно-свободные)     | $\alpha \in N; \beta \in (T \cup N)*$                                                                                     |
| 1           | MC, КЗ (конкретно-зависимые) | $\alpha \in (T \cup N)^\star \cdot N \cdot (T \cup N)^\star$<br>$\beta \in (T \cup N)*$; \|$\alpha$\| $\leq$$ \|$\beta$\| |
| $\emptyset$ | Без ограничений              |                                                                                                                           |
Распознающая - известна цепочка (a * a + a), строим цепочку.
Порождающая - используем грамматику, строим все цепочки.
Примитивно-рекурсивная функция и машина Тьюринга - это тип 0
__Пример:__
S -> aB
B -> bc             (3)
c -> b
-------------------------
S -> ABa
A -> cAAc        (2)
B -> a
-------------------------
AS -> ABC
Ab -> bbCb
B -> b
C -> c

Диаграмма Эйлера - связь между типами.
Также, как и в рекурсивных функциях. Если ФГ в центре, то одна и всех других типов.

# Лекция 13
#### 4.1.3 Формальные свойства грамматики

| №   | Название                                                              |     | Типы ФГ |     |     |
| --- | --------------------------------------------------------------------- | --- | ------- | --- | --- |
|     |                                                                       | 3   | 2       | 1   | 0   |
| 1   | $L_G = L(G) = \emptyset$                                              | +   | +       | -   | -   |
| 2   | \|L(G) = $\infty$                                                     | +   | +       | 0   | 0   |
| 3   | L(G) = T*                                                             | +   | -       | -   | -   |
| 4   | $L(G_1) \leq L(G_2)$?                                                 | +   | -       | -   | -   |
| 5   | $L(G_1) \equiv L(G_2)$?                                               | +   | -       | -   | -   |
| 6   | $L(G_1) \cap L(G_2) = \emptyset$                                      | +   | -       | -   | -   |
| 7   | $\forall \alpha, \beta \in (T \cup N)\star: \alpha \Rightarrow \beta$ | +   | +       | +   | -   |
| 8   |                                                                       | +   | -       | -   | -   |
| 9   |                                                                       | да  | -       | ?   | да  |
### 4.2 Автоматные грамматики в языке

###### T.
G = < T, N, R, S >
$\exists S = <A, Q, \delta, q_0, F >$
1) T -> A;
2) N -> Q;
3) S -> $q_0$ (S $\in N$; $q_0 \in Q$)
4) $[B \rightarrow aD]$ -> $[\delta(a, B) = D]$;
 $[B \rightarrow a]$ -> $[\delta(a, B) \in F]$
 __и наоборот__
__Пример:__ G:  R = { S - > aB ,
			B -> bS,
			B -> b}
	$\rightarrow^a$
(S)           (B)
	$\leftarrow^b$

$\frac{\bigtriangleup}{\bigtriangleup}$=

|     | S($q_0$) | B($q_1$) |
| --- | -------- | -------- |
| a   | B        |          |
| b   |          | S        |
#### 4.2.1 
$L^o \rightarrow S \rightarrow S^o \rightarrow G$
 КНА          минимизация  конечные команды
ДЗ: L = { a*, b*, $c^k$, d | m, n, k $\in$ N }
Реализовать цепочку

#### 4.2.2 Подходы к реализации алгоритма
1) 1-й подход
G -> S -> {$\alpha \in L(G)$
.       $\alpha$     {$\alpha \notin L(G)$

2) 2-й подход
G -> {$\alpha \in L(G)$
$\uparrow$      {$\alpha \notin L(G)$
$\alpha$

#### 4.3.1 Нормальные формы КС (конкретно-свободные) грамматики

НФ (КС грамматика)
НФ (Хомского)             (НФ Грейбах)
.            $G_х$                                                  $G_г$


###### O.
$G_х$: {A -> BC;
.       {A -> a;
.       {...
Справа либо 2 нетерминальных символа ($\in N$), либо 1 терминальный символ ($\in T$)


###### O.
$G_г$: {A -> a$\alpha$;
.      {A $\in N_i$;
.      {a $\in T$;
.      { $\alpha \in (N \cup T)\star$


###### T.
G: $\exists G_х; G_г$
L(G) = L($G_х$) = L($G_г$)
	   G
	$\swarrow$$\searrow$
    $G_х$$\leftrightarrow$$G_г$
Т.е. существует 4 алгоритма реализации

#### 4.3.2 Анализ КС грамматики
1) 1-й подход
G -> {$\alpha \in L(G)$
$\uparrow$     {$\alpha \notin L(G)$
$\alpha$ 
2) 2-й подход:
G -> $G_{х, г}$ -> $S_{МП}$ -> {$\alpha \in L(G)$
.                                 {$\alpha \notin L(G)$

ДЗ: привести пример $S_{МП}$ (КНА с магазинной памятью) (рекомендовано в КС)
- Реуйрд - Смит. Вводный курс

# Лекция 14
![[Pasted image 20250107205755.png]]


## 5. Структурно-стохастические модели и их применение 
G = < N, T, R, S >

###### O.
 $G_S$ = < N, T, R, S, $П_S, Пп_S, П_R, Пп_R$ >
 S = {$S_1, \ldots, S_n$} - набор (множество)  аксиом |S| $\geq$ 1
 S - мощность
 $П_S$ = {p} - вероятность (p $\in [0, 1]$)
 $Пп_S$: S -> $П_S$ - отображение множества аксиом
 $П_R$ = i $Пп_R$: R -> $П_R$;


 ###### O.
 $G_S^o$ - < N, T, R, S >; - характеристическая грамматика
По сути, она такая же, как и в обычной грамматике.
__Пример:__
$G_S$ = < N, T, R, S, $Пп_R$ >;
|S| = 1;
T = {a}
N = {S}
R = {S $\rightarrow^{0,8} aSa$;
.      {S $\rightarrow^{0,2} aa$

L($G_S$) = {$\alpha$ | S $\Rightarrow_{G_S}$ a} $\Rightarrow L(G_S)$ = { < $\alpha, P(a) >$
.                                                             {$\alpha \in T\star$
P($\alpha$) = P($S \Rightarrow_{G_S}^\star \alpha$);



###### O. СГ
$G_S$  L($G_S$)
$\sum(P(\alpha)) = 1$
$\alpha \in h(G_S)$

$\alpha$ = aaaaaa
S $\Rightarrow^{0,8} aSa \Rightarrow^{0,8} aaSaa \Rightarrow^{0,2} aaaaaa$
P($\alpha$) = 0,8 * 0,8 \* 0,2 = __0,128__

### 5.2 Стохастический КНА

###### O. СКНА
Без выхода: $S_S$= < X, Q, $Пп_0, \delta_S, Q_F$ >
X - входной алфавит
Q - алфавит внутренних состояний
$Пп_0$ - начальное распределение состояний КНА
S $\rightarrow П_S:$ $Пп_0$ = < $0,8^{q_0}; 0,1^{q_1}; 0,1^{q_2}$
$\delta_S$ - стохастическая функция переходов
$\delta_S: X \cdot Q \rightarrow X \cdot Q \cdot Q \rightarrow П_{\delta}: X \cdot Q \cdot Q \rightarrow П_{\delta}$
$Q_F$ - множество финальных состояний
$Q_F \leq Q$
__Пример:__ 
(1)$\longrightarrow^a$(2)$\longrightarrow^b$(3)$\longrightarrow^b$(4)
.             $\circlearrowleft^a$         $\circlearrowleft^b$ 
L(S) = {$a^n, b^m | m, n \leq 1$};
M=

|     | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- |
| 1   |     | a   |     |     |
| 2   |     | a   | b   |     |
| 3   |     |     | b   | b   |
| 4   |     |     |     |     |
CA:
M = ![[Pasted image 20250107212510.png]]
M(a)= 

|     | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- |
| 1   |     | 1   |     |     |
| 2   |     | 0,4 |     |     |
| 3   |     |     |     |     |
| 4   |     |     |     |     |
M(b)=

|     | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- |
| 1   |     |     |     |     |
| 2   |     |     | 0,6 |     |
| 3   |     |     | 0,6 |     |
| 4   |     |     |     | 0,4 |
__Замечание:__
Сумму элементов М(ЗД) по слоям должна быть равна 1.


###### T.
Любой однородный Марковский процесс (каждый переход должен иметь свою P) с дискретным временем и конечным количеством Q, может быть представлен, как язык, допускаемый СКНА


###### T.
Для любой СКНА:
CA$S_S$ $\exists$ СГ типа 3 $G_S$
L($S_S$) = L($G_S$) и наоборот
СА - стохастический автомат
СГ - стохастическая грамматика

Алгоритм построения СГ типа 3 по СА
$S_s = < X, Q, S_S, Q_F >$
$G_S = < T, N, S, R, Пп_R >$
1) T = X;
2) N = Q \ {#} = Q \ $Q_F$
3) $[A_i \rightarrow^{P_i}x_jA_k] \Leftrightarrow [S_S(x_jq_iq_k) = P_{ik}]$
$[A_i \rightarrow x_j \ldots] \Leftrightarrow [\delta_S(x_jq_i\#)=P_i]$
4) $S\cong A_i\cong q_i$ $Пп_0 = < Пп_{01}, Пп_{02}, \ldots, Пп_{0i}, \ldots >$
__Пример:__
$G_S = <T, N, R, S >$;
T = {a, b}; S = {S, A, B}

$R_S$ = {$S \rightarrow^1 aA$;
.         $A \rightarrow^{0,4} aA$;
.         $A \rightarrow^{0,5} bB$;
.         $A \rightarrow^{0,1}b$;
.         $B\rightarrow^{0,6}bB$;
.         $B\rightarrow^{0,4}b$}
{$q_1 \rightarrow S$
{$q_2 \rightarrow A$
{$q_3 \rightarrow B$
\
ДЗ: Построить СКНА по данной грамматике

__Пример:__
$\alpha$ = aabb;                   $Пп_0$ = < 1, 0, 0, 0 >
.                                   $Пп_F$ = < 0, 0, 0, 1 >
.                                   конечно
M(A)=

|     | 1   | 2   | 3   | #   |
| --- | --- | --- | --- | --- |
| 1   |     | 1   |     |     |
| 2   |     | 0,4 |     |     |
| 3   |     |     |     |     |
| #   |     |     |     |     |

M(B)=

|     | 1   | 2   | 3   | #   |
| --- | --- | --- | --- | --- |
| 1   |     |     |     |     |
| 2   |     |     | 0,1 | 0,1 |
| 3   |     |     | 0,1 | 0,4 |
| #   |     |     |     |     |
