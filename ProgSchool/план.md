84clear
Указатели
При выполнении инициализации переменной, ей автоматически присваивается свободный адрес памяти, и, любое значение, которое мы присваиваем переменной, сохраняется по этому адресу в памяти. Например:
```
int b = 8;
```
При выполнении этого стейтмента процессором, выделяется часть оперативной памяти. В качестве примера предположим, что переменной `b` присваивается ячейка памяти под номером 150. Всякий раз, когда программа встречает переменную `b` в выражении или в стейтменте, она понимает, что для того, чтобы получить значение — ей нужно заглянуть в ячейку памяти под номером 150.

Хорошая новость — нам не нужно беспокоиться о том, какие конкретно адреса памяти выделены для определенных переменных. Мы просто ссылаемся на переменную через присвоенный ей идентификатор, а компилятор конвертирует это имя в соответствующий адрес памяти. 
```
#include <iostream>

int main()

{

    int a = 7;

    std::cout << a << '\n'; // выводим значение переменной a

    std::cout << &a << '\n'; // выводим адрес памяти переменной a

    return 0;

}
```
## Оператор разыменования *

**Оператор разыменования** `*` позволяет получить значение по указанному адресу:

```
#include <iostream>

int main()

{

    int a = 7;

    std::cout << a << '\n'; // выводим значение переменной a

    std::cout << &a << '\n'; // выводим адрес переменной a

    std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a

    return 0;

}
```

Вывести результат

## Указатели

Теперь, когда мы уже знаем об операторах адреса и разыменования, мы можем поговорить об указателях.

**Указатель** — это переменная, значением которой является адрес ячейки памяти. Указатели объявляются точно так же, как и обычные переменные, только со звёздочкой между типом данных и идентификатором:
```
int *iPtr; // указатель на значение типа int

double *dPtr; // указатель на значение типа double

int* iPtr3; // корректный синтаксис (допустимый, но не желательный)

int * iPtr4; // корректный синтаксис (не делайте так)

int *iPtr5, *iPtr6; // объявляем два указателя для переменных типа int
```
Синтаксически язык C++ принимает объявление указателя, когда звёздочка находится рядом с типом данных, с идентификатором или даже посередине. Обратите внимание, эта звёздочка не является оператором разыменования. Это всего лишь часть синтаксиса объявления указателя.

Однако, при объявлении нескольких указателей, звёздочка должна находиться возле каждого идентификатора. Это легко забыть, если вы привыкли указывать звёздочку возле типа данных, а не возле имени переменной. Например:
```
int* iPtr3, iPtr4;
```
iPtr3 - указатель на int, iPtr4 - переменная типа int

По этой причине, при объявлении указателя, рекомендуется указывать звёздочку возле имени переменной. Как и обычные переменные, указатели не инициализируются при объявлении. Содержимым неинициализированного указателя является обычный мусор.
## Присваивание значений указателю

Поскольку указатели содержат только адреса, то при присваивании указателю значения — это значение должно быть адресом. Для получения адреса переменной используется оператор адреса:
```
int value = 5;

int *ptr = &value;
```
![[Pasted image 20240901171457.png]]

Вот почему указатели имеют такое имя: `ptr` содержит адрес значения переменной `value`, и, можно сказать, `ptr` _указывает_ на это значение.

Еще очень часто можно увидеть следующее:
```
#include <iostream>

int main()

{

    int value = 5;

    int *ptr = &value; // инициализируем ptr адресом значения переменной

    std::cout << &value << '\n'; // выводим адрес значения переменной value

    std::cout << ptr << '\n'; // выводим адрес, который хранит ptr

    return 0;

}
```

## В чём польза указателей?

Сейчас вы можете подумать, что указатели являются непрактичными и вообще ненужными. Зачем использовать указатель, если мы можем использовать исходную переменную?

Однако, оказывается, **указатели полезны в следующих случаях**:

   **_Случай №1:_ [Массивы](https://ravesli.com/urok-74-massivy-chast-1/) реализованы с помощью указателей**. Указатели могут использоваться для итерации по массиву.

   **_Случай №2:_ Они являются единственным способом динамического выделения памяти в C++**. Это, безусловно, самый распространенный вариант использования указателей.

   **_Случай №3:_ Они могут использоваться для передачи большого количества данных в функцию без копирования этих данных**.

   **_Случай №4:_ Они могут использоваться для передачи одной функции в качестве параметра другой функции**.

   **_Случай №5:_ Они используются для достижения полиморфизма при работе с наследованием**.

   **_Случай №6:_ Они могут использоваться для представления одной [структуры](https://ravesli.com/urok-61-struktury/)/класса в другой структуре/классе, формируя, таким образом, целые цепочки**.

Указатели применяются во многих случаях. Не волнуйтесь, если вы многого не понимаете из вышесказанного. Теперь, когда мы разобрались с указателями на базовом уровне, мы можем начать углубляться в отдельные случаи, в которых они полезны, что мы и сделаем на последующих уроках.


# Память в C++
у нас есть память в компьютере, ссд, оперативка, регистры в процессоре
Железяка, ей надо как-то управлять, ос делает с помощью сложных механизмов вроде виртуальной памяти, как именно она это делает, сейчас нас не интересует. Это совсем другое. Computer Science и все дела. Знать достаточно основы и для кодинга этого хватит.
Железо, операционка и на самом верху сидим мы с С++, где есть указатели и куча всего остального.
Указатели одна из фич языка, которая позволяет бегать по памяти, выделять освобождать, забывать ее освободить, что может привести к проблемам в каких-то серьезных проектах.

Почему можно не знать, как работает все внутри операционки?
Потому что у нас есть наш уровень абстракции, и мы на нем сидим, и все, что нам нужно знать об этой памяти, что она просто есть. ос дает нам иллюзию, что вся память в системе нам доступна. операционка взяла наше железо и представила память в виде огромного массива, с которым мы можем уже что-то делать

Переменная содержит данные 
int a = 10;
float b = 1.1;
char c = 'f'
std::string str = "hello";
у переменной есть тип и название, данные могут быть разных типов

если сейчас скомпилировать и запустить, у нас будет одна переменная int, в которой есть какое-то число


размер инта - 4/8 байт, в зависимости от архитектуры процессора. сейчас почти везде 8 байт.

Есть мысли, где лежит этот инт? мы запустили программу и нам какая-то память далась на автомате.

если посмотреть на размер исполняемого файла/exe\`шника, то в нем явно что-то есть.
мы не просили ничего, программа сама выделила 8 байт. вы может сказать тип данных выделяет сам по себе или функция main. близко, но нет. 
когда мы запускаем программу, она собирается в какой-то целостный кусок, на который можно кликнуть, и она запустится. этот самый кусок состоит из нескольких частей.
их там масса, но самое важное, что там есть сегменты для хранения видов данных/типов. 
![[Pasted image 20240901235943.png]]

слово вид я использую как обозначение того, какой вид хранения переменной  
там есть стек, где хранится наша переменная - локальные данные, локальный вид хранения. размер дефолтно - около 2мб, но его можно расширять. также в файле есть часть для хранения нашего скомпилированного кода, часть для хранения глобальных и статических переменных.

самое интересное в файле есть еще такая штука heap или куча
такая память, которая растет во время выполнения. основная его фишка - он растет динамически

- **Стек** — это ваш рабочий стол, на котором вы выполняете текущую работу. Вы можете быстро что-то положить на стол или убрать в ящик. Но место на столе ограничено, и все, что на нем находится, удаляется, когда вы заканчиваете работу (когда функция завершает выполнение).
- **Куча** — это архив или склад с ящиками, которые могут хранить документы долгое время. Если вам нужно больше места или хотите сохранить что-то надолго, вы идете в архив и берете ящик. Когда он вам больше не нужен, вы возвращаете его на место (освобождаете память).

```
int a = 10;

int *ptr = &a;

std::cout << ptr << std::endl;

std::cout << *ptr << std::endl;
```

### 2. Ссылка: «Псевдоним»

Представьте, что у вас есть коллега по имени Анна, и у нее есть псевдоним — скажем, "Энн". Когда вы обращаетесь к Энн, вы на самом деле говорите с Анной.

- **Ссылка** — это как псевдоним. Это другое имя для того же объекта. Если вы измените что-то в «Энн», Анна тоже это почувствует, потому что это одно и то же лицо.

### 3. Указатель: «Адрес дома»

Подумайте о своем доме и его адресе:

- **Переменная** — это дом. В нем живут данные.
- **Указатель** — это адрес дома. Он указывает, где этот дом находится. Вы можете передавать адрес кому-то, чтобы они знали, куда идти, но сам адрес не является домом, это лишь способ его найти.

 это наша переменная инт с какими-то данными: 
 int a = 10;
 int \*ptr = &a;
 а это указатель на эту переменную, синтаксис такой, что мы декорируем (обрамляем) интежер этой звездочкой и получаем указатель на инт, а ампераснт - это адрес переменной, в которой лежат данные - ссылка
тоже самое и ссылки - ссылки - синтаксический сахар для указателей.



Ссылка — это другой способ обращения к переменной. Она создается путем указания имени другой переменной с использованием оператора `&`
int a = 10; int& ref = a;

#### Арифметика указателей
Одной из мощных возможностей указателей является их арифметика. Если у вас есть указатель на элемент массива, вы можете перемещаться по массиву, добавляя или вычитая из указателя целые числа:
```
int arr[] = {1, 2, 3, 4, 5}; 
int* p = arr; // указатель на первый элемент 
p++; // теперь p указывает на второй элемент массива
```


```
int arr[5] = {1, 2, 3, 4, 5}; // [1] [2] [3] [4]

int* p = arr;

std::cout << p << std::endl;

p++;

std::cout << p << std::endl;
```
```
int arr[] = {1, 2, 3, 4, 5};

int* p = arr; // указатель на первый элемент

да for (int i = 0; i < 5; i++) {

std::cout << p + i << std::endl;

}
```
### 4. Арифметика указателей: «Улица с домами»

Представьте, что вы идете по улице с домами:

- **Массив** — это улица, на которой расположены дома (элементы массива).
- **Указатель** — это человек, который идет по улице, держа карту с номерами домов (индексами массива).
- Когда вы делаете шаг вперед (прибавляете к указателю), вы переходите к следующему дому на улице (следующему элементу массива).

Указатели имеют множество применений в C++:

- **Динамическое выделение памяти**: Указатели позволяют выделять и освобождать память в куче с помощью `new` и `delete`.
- **Массивы и строки**: Указатели используются для работы с массивами и строками. Например, строка в C++ — это просто указатель на массив символов.
- **Функции и обратные вызовы**: Указатели на функции позволяют передавать функции как аргументы другим функциям.
- **Эффективность**: Указатели позволяют передавать большие структуры данных по адресу, а не по значению, что экономит время и память.
- **Системное программирование**: В низкоуровневом программировании указатели незаменимы для управления аппаратными ресурсами, например, при работе с регистрами процессора или устройствами ввода-вывода.

### 5. Польза указателей: «Руководитель и задачи»

Подумайте о руководителе, который раздает задачи:

- Руководитель может сам выполнять задачи (прямое управление переменными) или дать кому-то указания (использовать указатели), чтобы они выполнили работу.
- Указатель позволяет руководителю передать работу, не занимая себя (эффективное использование ресурсов). Он просто указывает, где находится задача (данные), и другой сотрудник (функция или другой код) может с ней работать.

Таким образом, указатели и ссылки играют ключевую роль в управлении памятью, предоставляя гибкость и контроль, которые позволяют эффективно использовать ресурсы и писать мощные программы.



**Правильный ответ:** b) Переменная, хранящая адрес другой переменной
**Правильный ответ:** b) \*
**Правильный ответ:** a) Программа завершится с ошибкой (сегментация)
**Правильный ответ:** b) 20
**Правильный ответ:** c) Ссылки являются синонимами переменных, на которые они указывают


