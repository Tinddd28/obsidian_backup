## Паттерны многопоточности: Генератор, Стоп-Кран, Паттерн обработки ошибок
### Канал всегда должен быть закрыт отправителем
Каналы всегда нужно закрывать, чтобы избежать утечки памяти, или **утечки горутины**. При создании горутины выделяется память в куче. После завершения работы горутины, память освобождается. Утечка памяти происходит, когда горутина не завершается и зависает в фоновом режиме в течение всего времени существования приложения.
Чтение из закрытого канала даёт два параметра. Первый — это значение `nil`. Второй — логический параметр, который сообщает, открыт канал или нет (`true`, `false`).

Отправка данных в закрытый канал вызывает панику. Поэтому канал должен закрывать отправитель, а не получатель. Это предотвращает отправку данных отправителем в закрытый канал и обеспечивает согласованность.

### Паттерн Генератор

Обычно многопоточная программа Go состоит из производителя и потребителя, которые общаются через канал. Производитель генерирует поток данных и отправляет их по каналу потребителю. Паттерн Генератор генерирует данные в отдельной горутине, что позволяет параллельно обрабатывать их и создавать новые.

Это работает так: отправка и получение блокируются до тех пор, пока отправитель и получатель не будут готовы. Такое свойство позволяет дождаться запроса следующего значения.
```
// generator — генератор, который создает канал и сразу возвращает его
func generator(input []int) chan int {
    inputCh := make(chan int)

    // через отдельную горутину генератор отправляет данные в канал
    go func() {
        // закрываем канал по завершению горутины — это отправитель
        defer close(inputCh)
``
        // перебираем данные в слайсе
        for _, data := range input {
            // отправляем данные в канал inputCh
            inputCh <- data
        }
    }()

    // возвращаем канал inputCh
    return inputCh
}
```
Этот паттерн позволяет работать генератору и потребителю параллельно, не накапливая все данные в оперативной памяти. Благодаря этому снижается задержка до получения первого значения на выходе из обработчика, так как не нужно ждать, пока сгенерируются все данные. Такой подход позволяет обрабатывать большие объёмы данных, вплоть до бесконечных, используя небольшой объём памяти, достаточный для обработки одного элемента.

### Паттерн обработки ошибок в горутинах

Параллельная горутина работает независимо от своего родителя. Иногда будет сложно определить правильное поведение программы в случае ошибки.
Лучше всего передать ошибки в основной поток и обработать их там.
![[erorr_in_goroutine.png]]

Другой способ обработки ошибок — использование пакета `errgroup`. Он обеспечивает синхронизацию, распространение ошибок и отмену контекста для групп горутин, работающих над общей задачей. Если в одной из горутин возникает ошибка, она завершается, а ошибка возвращается. Горутины, которые уже выполняются, продолжат работу до завершения. Но ошибка будет возвращена только из той горутины, которая первая её сгенерировала.

```
package main

import (
    "context"
    "errors"
    "log"

    "golang.org/x/sync/errgroup"
)

func main() {
    // создаём переменную errgroup
    g := new(errgroup.Group)

    // наши данные
    input := []int{1, 2, 3, 4}

    // генератор возвращает канал, через который он отправляет данные
    inputCh := generator(input)

    for data := range inputCh {
        // тут объявляем новую переменную внутри цикла, чтобы копировать переменную 
        // в замыкание каждой горутины, а не использовать одно общее на всех значение.
        data := data

        // потребитель должен возвращать ошибку.
        // сигнатура анонимной функции всегда такая как в примере.
        g.Go(func() error {
            // получаем ошибку
            err := callDatabase(data)
            if err != nil {
                // возвращаем ошибку
                return err
            }

            return nil
        })
    }

    // здесь ждём выполнения горутин, и если хотя бы в одной из них возникает ошибка, 
    // то присваиваем её err и обрабатываем. В этом случае просто выводим на экран.
    // Обратите внимание, что g.Wait() ждёт завершения всех запущенных горутин, даже 
    // если приозошла ошибка.
    if err := g.Wait(); err != nil {
        log.Println(err)
    }
}

// generator возвращает канал, а затем отправляет в него данные
func generator(input []int) chan int {
    // создаём канал данных
    inputCh := make(chan int)

    // вызываем горутину в которой отправляем данные в канал inputCh
    go func() {
        // по завершении горутины закрываем канал
        defer close(inputCh)

        // перебираем данные в слайсе
        for _, data := range input {
            // отправляем данные из слайса в канал
            inputCh <- data
        }
    }()

    // возвращаем канал с данными
    return inputCh
}

// callDatabase просто возвращает ошибку
func callDatabase(data int) error {
    // допустим ошибка возникнет когда data = 3
    if data == 3 {
        return errors.New("ошибка запроса к базе данных")
    }

    return nil
}
```

### Паттерн Стоп-Кран

Благодаря ему вместо выполнения 100 HTTP-запросов можно уменьшить параллельный процесс до 20 запросов и повторить этот процесс пять раз. На обработку потребуется больше времени, но зато сеть получит «передышку», поскольку ей будет нужно обработать одновременно только 20 запросов.![[stop_cran.png]]
#### Использование дополнительного канала для блокировки
```
package main

import (
 "log"
 "time"
)

func main() {
    input := []int{1, 2, 3, 4, 5, 6}
    handler(input)
    time.Sleep(time.Second)
}

// handler получает данные из слайса
func handler(input []int) {
    // канал для явной отмены
    doneCh := make(chan struct{})
    // когда выходим из handler — сразу закрываем канал doneCh
    defer close(doneCh)

    // теперь передаём и канал отмены doneCh
    inputCh := generator(doneCh, input)

    // забираем данные из канала
    for data := range inputCh {
        // если в данных 3 — выходим из handler
        if data == 3 {
            log.Println("Прекращаем обработку данных из канала")
            return
        }
        log.Println(data)
    }
    log.Println("Данные во входном канале закончились")
}

// generator возвращает канал с данными
func generator(doneCh chan struct{}, input []int) chan int {
    // канал, в который будем отправлять данные из слайса
    inputCh := make(chan int)

    // горутина, в которой отправляются данные в канал inputCh
    go func() {
        // по завершении закрываем канал inputCh
        defer close(inputCh)

        // перебираем данные в слайсе input
        for _, data := range input {
            select {
            // если канал doneCh закрылся - сразу выходим из горутины
            case <-doneCh:
                log.Println("Останавливаем генератор")
                return
            // отправляем данные в канал inputCh
            case inputCh <- data:
            }
        }
    }()

    // возвращаем канал с данными
    return inputCh
}
```
#### Использование контекста для блокировки
```
package main

import (
    "log"
    "context"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())

    input := []int{1, 2, 3, 4, 5, 6}

    go func() {
        handler(ctx, input)
        cancel()
    }

    time.Sleep(time.Seconds)
}

// передадим контекст и данные из слайса
func handler(ctx context.Context, input []int) {
    // передаём данные и контекст в генератор
    inputCh := generator(ctx, input)

    // теперь канал для отмены не нужен

    for data := range inputCh {
        if data == 3 {
            log.Println("Прекращаем обработку данных из канала")
            return
        }
        log.Println(data)
    }
    log.Println("Данные во входном канале закончились")
}

func generator(ctx context.Context, input []int) chan int {
    inputCh := make(chan int)

    go func() {
        defer close(inputCh)

        for _, data := range input {
            select {
            // вместо отменяющего канала используем Context.Done()
            case <-ctx.Done():
                log.Println("Останавливаем генератор")
                return
            case inputCh <- data:
            }
        }
    }()

    return inputCh
}
```

Как видите, этот способ мало чем отличается от предыдущего. В предыдущем примере использовали канал отмены `doneCh`, в этом — `Context.Done()`, который передали в `handler`.

## Паттерны многопоточности: Конвейер, Fan-In, Fan-Out, Семафор

### Паттерн Конвейер

**Конвейер** — шаблон, позволяющий разбить сложную задачу на несколько более простых подзадач. При этом вывод первой подзадачи будет вводом для следующей. Этот процесс повторяется до тех пор, пока все подзадачи не будут выполнены. На схеме ниже вы можете рассмотреть, как выглядит Конвейер без использования каналов и горутин.
![[konveer.png]]
Преимущества конвейера заключается, во-первых, в том, что все этапы отвечают только за одну задачу. А во-вторых, эти этапы модульные, поэтому их можно комбинировать.
![[konveer_multhread.png]]
[[code of pattern]]

### Паттерны Fan-In и Fan-Out

Если один из этапов конвейера занимает больше времени и ресурсов, чем другие, работа всех остальных этапов будет заблокирована. Чтобы избежать этого, можно использовать **паттерн Fan-Out**. Он позволяет увеличить количество рабочих на этапах с наибольшей нагрузкой. Принцип его работы отображён на схеме ниже.
![[fan_out.png]]
В паттерне Fan-Out создаётся большее количество горутин на определенном этапе, что увеличивает его пропускную способность.

**Паттерн Fan-In** объединяет несколько результатов в один канал. Этот процесс также называют **мультиплексированием**. На схеме ниже — принцип работы этого паттерна.
![[fan_int.png]]

### Паттерн семафор


### Паттерн Worker Pool
Паттерн **Worker Pool**, или **Пул рабочих процессов** (также известный как **Пул потоков**) — это шаблон многопоточности, в котором создаётся пул из рабочих процессов для одновременной обработки задач из очереди. Главные компоненты паттерна: система очередей для доставки задач воркерам (работникам) и логика получения задач. Обычно система очередей представляет собой канал, а логика получения задач заключается в том, что бездействующие воркеры (работники) будут брать задачи в порядке очереди.